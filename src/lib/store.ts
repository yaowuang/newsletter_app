import { create } from 'zustand';
import { nanoid } from 'nanoid';
import { horizontalLineLibrary, resolveThemedLine } from './horizontalLines';
import { allLayouts, Layout, LayoutVariant } from '@/lib/layouts';
import { allThemes, Theme } from '@/lib/themes';
import { buildInitialBlocks, createUserTextBlock, defaultSectionTemplates } from './initialData';
import { AppState, TextBlock, ImageElement, HorizontalLineElement } from './types';


// Note: Default section templates & initial block builders have been moved to initialData.ts


const initialBlocks = buildInitialBlocks();
const initialLayout = allLayouts.find(l => l.sections === initialBlocks.length)!;

export const useStore = create<AppState>()(
  (set, get) => ({
    title: 'Newsletter Title',
    date: 'August 6, 2025',
  textBlocks: initialBlocks,
  horizontalLines: [],
  images: [],
  selectedElement: null,
    sectionStyles: {},
    theme: allThemes[0],
    layout: { base: initialLayout, variant: initialLayout.variants[0] },

    setTitle: (title) => set({ title }),
    setDate: (date) => set({ date }),

  addTextBlock: () => {
    const count = get().textBlocks.length;
    const newBlock = createUserTextBlock(count);
    set(state => ({ textBlocks: [...state.textBlocks, newBlock] }));
  },

  addHorizontalLine: (props = {}) => {
    const state = get();
    // Get the default color for classic-solid if no color is provided
    const defaultLibItem = horizontalLineLibrary.find(item => item.id === 'classic-solid');
    const defaultColor = props.color || defaultLibItem?.defaultColor || state.theme.styles.section.borderColor || '#888';
    
    const newLine: HorizontalLineElement = {
      id: nanoid(),
      type: 'horizontalLine',
      x: 40,
      y: 140,
      width: 400, // use numeric width for draggable/resizable line
      height: 24, // default height for SVG scaling
      color: defaultColor,
      thickness: 2,
      style: 'solid',
      ...props,
    };
    set(state => ({ horizontalLines: [...state.horizontalLines, newLine] }));
  },

  updateHorizontalLine: (id: string, newProps: Partial<HorizontalLineElement>) => {
    set(state => ({
      horizontalLines: state.horizontalLines.map(line => {
  if (line.id !== id) return line;
  // Allow autoGenerated decorative lines to be repositioned even if locked (layout-driven)
  if (line.locked && !line.autoGenerated && !('locked' in newProps)) return line; // do not mutate if locked unless unlocking
        return { ...line, ...newProps };
      })
    }));
  },

    addImage: () => {
      const newImage: ImageElement = { id: nanoid(), type: 'image', src: '', x: 50, y: 50, width: 200, height: 150 };
      set(state => ({ images: [...state.images, newImage] }));
    },

    updateTextBlock: (id, property, value) => {
      set(state => ({
        textBlocks: state.textBlocks.map(b => (b.id === id && !b.locked)
          ? { ...b, [property]: value } as TextBlock
          : b)
      }));
    },

    updateImage: (id, newProps) => {
      set(state => ({ images: state.images.map(img => {
        if (img.id !== id) return img;
        if (img.locked && !('locked' in newProps)) return img;
        return { ...img, ...newProps };
      }) }));
    },

    selectElement: (id, type) => {
      if (!id || !type) set({ selectedElement: null });
      else set({ selectedElement: { id, type } });
    },

    deleteElement: (id, type) => {
      set(state => {
        if (type === 'image' && state.images.find(i => i.id === id && i.locked)) return { ...state };
        if (type === 'text' && state.textBlocks.find(b => b.id === id && b.locked)) return { ...state };
        if (type === 'horizontalLine' && state.horizontalLines.find(l => l.id === id && l.locked)) return { ...state };
        return {
          textBlocks: type === 'text' ? state.textBlocks.filter(b => b.id !== id) : state.textBlocks,
          images: type === 'image' ? state.images.filter(i => i.id !== id) : state.images,
          horizontalLines: type === 'horizontalLine' ? state.horizontalLines.filter(l => l.id !== id) : state.horizontalLines,
          selectedElement: null,
        };
      });
    },

    setElementLocked: (id, type, locked) => {
      const updater = <T extends { id: string }>(arr: T[]) => arr.map(el => el.id === id ? { ...el, locked } : el);
      if (type === 'text') set(state => ({ textBlocks: updater(state.textBlocks) }));
      else if (type === 'image') set(state => ({ images: updater(state.images) }));
      else if (type === 'horizontalLine') set(state => ({ horizontalLines: updater(state.horizontalLines) }));
    },

    updateStyle: (blockId, newStyles) => {
      set(state => ({
        sectionStyles: (() => {
          const blk = state.textBlocks.find(b => b.id === blockId);
          if (blk?.locked) return state.sectionStyles; // ignore when locked
          return { ...state.sectionStyles, [blockId]: { ...(state.sectionStyles[blockId] || {}), ...newStyles } };
        })()
      }));
    },

  setTheme: (theme) => {
      const state = get();
      const newBorderColor = theme.styles.section.borderColor || '#888';
      const oldBorderColor = state.theme.styles.section.borderColor || '#888';
      
      // Update existing non-SVG horizontal lines to use the new theme's border color
      // Only update lines that are currently using the old theme's default color
      const updatedHorizontalLines = state.horizontalLines.map(line => {
        // Only update non-SVG lines (solid, dashed, dotted, shadow)
        if (line.style !== 'clipart') {
          // Find the corresponding library item
          const libItem = horizontalLineLibrary.find(item => 
            (line.style === 'solid' && item.id === 'classic-solid') ||
            (line.style === 'dashed' && item.id === 'classic-dashed') ||
            (line.style === 'dotted' && item.id === 'classic-dotted') ||
            (line.style === 'shadow' && item.id === 'shadow')
          );
          
          // If the library item doesn't have a default color (meaning it should use theme color)
          // and the current line color matches the old theme's border color, update it to new theme color
          if (libItem && !libItem.defaultColor && line.color === oldBorderColor) {
            return { ...line, color: newBorderColor };
          }
        }
        return line;
      });
      
      // Refresh auto-generated themed lines
  const refreshed: HorizontalLineElement[] = updatedHorizontalLines.map(line => {
        if (line.autoGenerated && line.decorationKey) {
          const deco = state.layout.variant.decorations?.find(d => `${state.layout.base.id}:${state.layout.variant.name}:${d.position}:${d.sectionIndex ?? ''}` === line.decorationKey);
          if (deco && deco.lineId === 'themed') {
            const themed = resolveThemedLine(theme.name);
            const style: HorizontalLineElement['style'] = themed.type === 'svg'
              ? 'clipart'
              : themed.id.includes('dashed') ? 'dashed'
              : themed.id.includes('dotted') ? 'dotted'
              : themed.id === 'shadow' ? 'shadow' : 'solid';
            return {
              ...line,
              style,
              clipartSrc: themed.type === 'svg' ? themed.preview : undefined,
              color: themed.defaultColor || newBorderColor
            };
          }
        }
        return line;
      });
      set({ 
        theme, 
        sectionStyles: {},
        horizontalLines: refreshed
      });
    },
    setThemeTitleFont: (font: string) => set(state => ({ theme: { ...state.theme, styles: { ...state.theme.styles, title: { ...state.theme.styles.title, fontFamily: font } } } })),
    setThemeDateFont: (font: string) => set(state => ({ theme: { ...state.theme, styles: { ...state.theme.styles, date: { ...state.theme.styles.date, fontFamily: font } } } })),
    setThemeTitleColor: (color: string) => set(state => ({ theme: { ...state.theme, styles: { ...state.theme.styles, title: { ...state.theme.styles.title, color } } } })),
    setThemeDateColor: (color: string) => set(state => ({ theme: { ...state.theme, styles: { ...state.theme.styles, date: { ...state.theme.styles.date, color } } } })),
    setThemeTitleAlignment: (align) => set(state => ({ theme: { ...state.theme, styles: { ...state.theme.styles, title: { ...state.theme.styles.title, textAlign: align } } } })),
    setThemeDateAlignment: (align) => set(state => ({ theme: { ...state.theme, styles: { ...state.theme.styles, date: { ...state.theme.styles.date, textAlign: align } } } })),
    setThemePageBackgroundColor: (color) => set(state => ({ theme: { ...state.theme, styles: { ...state.theme.styles, page: { ...state.theme.styles.page, backgroundColor: color } } } })),
    setThemePageBackgroundImage: (image) => set(state => ({ theme: { ...state.theme, styles: { ...state.theme.styles, page: { ...state.theme.styles.page, backgroundImage: image || undefined } } } })),
    setThemePageBackgroundSize: (size) => set(state => ({ theme: { ...state.theme, styles: { ...state.theme.styles, page: { ...state.theme.styles.page, backgroundSize: size || undefined } } } })),
    setThemePageBackgroundPosition: (position) => set(state => ({ theme: { ...state.theme, styles: { ...state.theme.styles, page: { ...state.theme.styles.page, backgroundPosition: position || undefined } } } })),
    setThemePageBackgroundRepeat: (repeat) => set(state => ({ theme: { ...state.theme, styles: { ...state.theme.styles, page: { ...state.theme.styles.page, backgroundRepeat: repeat || undefined } } } })),
    setThemePageBackgroundImageOpacity: (opacity) => set(state => ({ theme: { ...state.theme, styles: { ...state.theme.styles, page: { ...state.theme.styles.page, backgroundImageOpacity: Math.min(1, Math.max(0, opacity)) } } } })),

    setLayout: (layout) => {
      set(state => {
        const { base, variant } = layout;
        const theme = state.theme;
        const decorations = variant.decorations || [];
        const newAutoLines = decorations.map(dec => {
          const key = `${base.id}:${variant.name}:${dec.position}:${dec.sectionIndex ?? ''}`;
          const existing: HorizontalLineElement | undefined = state.horizontalLines.find(l => l.autoGenerated && l.decorationKey === key);
          const libItem = dec.lineId === 'themed' ? resolveThemedLine(theme.name) : horizontalLineLibrary.find(l => l.id === dec.lineId);
          const color = libItem?.defaultColor || theme.styles.section.borderColor || '#888';
          // Initial coarse placement; will be refined in canvas via DOM measurements
          let y = 125; // after title
          if (dec.position === 'afterTitle') y = 125;
          else if (dec.position === 'afterDate') y = 165;
          else if (dec.position === 'beforeSections') y = 200;
          else if (dec.position === 'afterSections') y = 920;
          else if (dec.position === 'afterSection' && typeof dec.sectionIndex === 'number') {
            y = 220 + dec.sectionIndex * 110;
          }
          const x = 40;
          const width = 400;
          let baseLine: HorizontalLineElement;
          if (existing) {
            baseLine = existing;
          } else {
            baseLine = {
              id: nanoid(),
              type: 'horizontalLine',
              x, y,
              width,
              height: libItem?.type === 'svg' ? 24 : undefined,
              color,
              thickness: 2,
              style: libItem ? (libItem.type === 'svg' ? 'clipart' : libItem.id.includes('dashed') ? 'dashed' : libItem.id.includes('dotted') ? 'dotted' : libItem.id === 'shadow' ? 'shadow' : 'solid') : 'solid',
              clipartSrc: libItem?.type === 'svg' ? libItem.preview : undefined,
              autoGenerated: true,
              decorationKey: key,
              locked: true,
            };
          }
          return { ...baseLine, x, y, color };
        });
        const keptManual = state.horizontalLines.filter(l => !l.autoGenerated);
        // Apply layout-provided alignment to theme styles (non-destructive for unspecified fields)
        const updatedTheme: Theme = {
          ...theme,
          styles: {
            ...theme.styles,
            title: { ...theme.styles.title, textAlign: variant.titleAlign || theme.styles.title.textAlign },
            date: { ...theme.styles.date, textAlign: variant.dateAlign || theme.styles.date.textAlign }
          }
        };
        return { layout, horizontalLines: [...keptManual, ...newAutoLines], theme: updatedTheme };
      });
    },

    setSectionCount: (count) => {
      const currentBlocks = get().textBlocks;
      if (count === currentBlocks.length) return;
      if (count > currentBlocks.length) {
        const newBlocks = Array.from({ length: count - currentBlocks.length }, (_, i) =>
          createUserTextBlock(currentBlocks.length + i)
        );
        set({ textBlocks: [...currentBlocks, ...newBlocks] });
      } else {
        set({ textBlocks: currentBlocks.slice(0, count) });
      }
      get().selectElement(null);
    },
    loadSnapshot: (snapshot) => {
      try {
        if (!snapshot || typeof snapshot !== 'object') return;
        // Basic version gating if needed later
        set({
          title: snapshot.title ?? get().title,
          date: snapshot.date ?? get().date,
          textBlocks: Array.isArray(snapshot.textBlocks) ? snapshot.textBlocks : get().textBlocks,
          images: Array.isArray(snapshot.images) ? snapshot.images : get().images,
          sectionStyles: snapshot.sectionStyles ?? get().sectionStyles,
          theme: snapshot.theme ?? get().theme,
          layout: snapshot.layout ?? get().layout,
          selectedElement: null,
        });
      } catch (e) {
        console.error('Failed to load snapshot', e);
      }
    },
    swapTextBlocks: (id1, id2) => {
      set(state => {
        const i1 = state.textBlocks.findIndex(b => b.id === id1);
        const i2 = state.textBlocks.findIndex(b => b.id === id2);
        if (i1 === -1 || i2 === -1 || i1 === i2) return {};
        const newBlocks = [...state.textBlocks];
        [newBlocks[i1], newBlocks[i2]] = [newBlocks[i2], newBlocks[i1]];
        return { textBlocks: newBlocks };
      });
    }
  })
);
